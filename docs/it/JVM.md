## 类加载

1. 类在什么时候被加载?

   1. Java程序对类的使用方式可分为两种:**主动使用**与**被动使用**。一般来说只有当对类的首次主动使用的时候才会导致类的初始化，所以**主动使用**又叫做**类加载过程中“初始化”开始的时机**。那啥是主动使用呢？

2. 类的主动使用包括以下六种【超级重点】：

    1. 创建类的实例，也就是new的方式
    2. 访问某个类或接口的静态变量，或者对该静态变量赋值（加final修饰的常量除外）
    3. 调用类的静态方法
    4. 反射（如 Class.forName(“com.gx.yichun”)）
    5. 初始化某个类的子类，则其父类也会被初始化
    6. Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是Main方法的类会首先被初始化. 
    7. 最后注意一点对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块），这句话在继承、多态中最为明显！

4. 类的被动使用:

   1. 通过子类引用父类静态字段/方法
   2. 常量使用
   3. 通过数组定义引用(如 A[] a )

5. 类初始化代码执行顺序: 

   - 准备(常量赋值) -> 初始化 (静态变量赋值,静态代码块执行) ->实例化(普通代码块执行)

5. **类加载过程**

   1. **加载**：
- 查找并加载类的二进制数据到java虚拟机中
  
- 将获取到的二进制字节流转化成一种**数据结构并放进方法区**
  
-  在内存中生成一个代表此类的java.lang.**Class对象**，作为访问方法区中各种数据的**接口**
      
2. **连接：**
  
   - **验证：** 确保被加载的类的正确性
      - **准备：**为类的**静态变量**分配内存，并将其初始化为默认值，但是到达初始化之前类变量都没有初始化为真正的初始值（如果是被 `final` 修饰的类变量，则直接会被初始成用户想要的值。）
      - **解析**：把类中的**符号引用转换为直接引用**，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程
   
3. **初始化**：为类的静态变量赋予正确的初始值
  
7. 加载阶段做了什么?

   -  **.class文件（二进制数据）——>读取到内存——>数据放进方法区——>堆中创建对应Class对象——>并提供访问方法区的接口** 

8. 验证阶段做了什么?

   1. **文件格式验证**：验证字节流是否符合Class文件格式的规范；例如：是否以 `0xCAFEBABE`开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
   2. **元数据验证**：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 `java.lang.Object`之外。
   3. **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
   4. **符号引用验证**：确保解析动作能正确执行。
   5. 验证阶段是非常重要的，但**不是必须的**，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 `-Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 

9. 准备阶段做了什么?

   1. 为类变量分配内存
   2. 初始化常量,并且赋值
   3. 初始化静态变量,赋类型默认值

10. 解析阶段一定在初始化之前吗?

    1. 不一定,为了支持动态绑定特性,解析阶段可以出现在初始化之后

11. 什么是动态绑定?

    1.  在运行时根据具体对象的类型进行绑定。  在编译时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。对应为Java方法重写时的多态。（父子继承中方法有多态，属性没有）

12. 初始化阶段有什么别名吗？

    1. 初始化阶段jvm会执行编译阶段收集static类变量赋值和static代码块而自动生成的<clinit>（）方法。

       ```java
          static int i =1;
           static {
               i = 0;
               System.out.println(i);
           }
          // static int i =1; // 如果写在这里会报错,说明编译器是顺序收集代码的,而不会自动做排序
       ```

       

12. **创建对象的步骤？**

     - **类加载机制检查**：首先检查是否已加载对应的lass类
     - **分配内存**：采用指针碰撞、空闲列表或TLAB进行分配
     - **初始化零值：**对象的实例字段不需要赋初始值也可以直接使用其默认零值，就是这里起得作用
     - **设置对象头：**存储对象自身的运行时数据，类型指针
     - **执行 init方法 **：为对象的字段赋值
     
13. **对象的生命周期**

     1. 创建阶段 -  对象的初始化
     2. 使用阶段 - 被强引用使用
     3. 不可见阶段 - 超出作用域至不可达阶段(可能还被静态变量或者JNI等GC ROOT引用着)
     4. 不可达阶段 - 从GC ROOT无法再可达
     5. 收集阶段 - 开始准备进行垃圾回收,如果重写finalize,执行finalize方法;否则直接进入下一阶段
     6. 终结阶段 - 等待垃圾回收
     7. 重新分配阶段 - GC 进行空间回收或内存再分配,对象消失

## 双亲委派机制

1. 为什么要使用双亲委派机制?

    1. 系统类防止内存中出现多份同样的字节码(耗费内存/执行结果未知)
    2. 保证Java程序安全稳定运行(防止jdk核心类被篡改)

2. 为什么tomcat要破坏双亲委托机制?

    1. 【**应用间隔离问题】**一个web容器可能需要部署两个应用程序，不同的应用程序可能会**依赖同一个第三方类库的不同版本**，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。

    2. 【**共享问题**】部署在同一个web容器中**相同的类库相同的版本可以共享**。否则，如果服务器有10个应用程

    序，那么要有10份相同的类库加载进虚拟机。

    3. 【**容器和应用隔离问题**】**web容器也有自己依赖的类库，不能与应用程序的类库混淆**。基于安全考虑，应该让容器的类库和程序的类库隔离开来。

    4. 【**热加载问题**】web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。

3. tomcat如何实现jsp热加载?

    1. 我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，**每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件**

4. 如何破坏双亲委任模型?

    1. 启动时:  java -Djava.system.class.loader= 你的class loader全限定类名

    2. 运行时:

       ```java
       Thread.currentThread().setContextClassLoader(你的classloader);
       ```

    3. OSGi为每个bundle提供一个类加载器，该加载器能够看到bundle Jar文件内部的类和资源； 

5. 如何自己实现class loader,实现双亲委托机制和忽视两种?

    1.  需要保留双亲委派模型：extends ClassLoader，重写 findClass()
    2.  破坏双亲委派模型： extends ClassLoader,直接重写 loadClass()

## class字节码结构

 [JVM系列十一（Class 文件结构）. - JMCui - 博客园 (cnblogs.com)](https://www.cnblogs.com/jmcui/p/12627180.html) 

## JVM系列

 [Java虚拟机 - 随笔分类 - JMCui - 博客园 (cnblogs.com)](https://www.cnblogs.com/jmcui/category/1503029.html) 

## 卡表 Card Table

- 

## metaspace

### 为什么要移除持久代,改用metaspace?

- 从内因来说，持久代大小受到-XX：PermSize和-XX：MaxPermSize两个参数的限制，而这两个参数又受到JVM设定的内存大小限制，这就导致**在使用中可能会出现持久代内存溢出的问题**,而metaspace默认无最大内存限制

### metaspace常用jvm参数

- | MetaspaceSize         | 初始化的Metaspace大小，控制Metaspace发生GC的阈值。GC后，动态增加或者降低MetaspaceSize，默认情况下，这个值大小根据不同的平台在12M到20M之间浮动 |
  | --------------------- | ------------------------------------------------------------ |
  | MetaspaceSize         | Metaspace初始大小                                            |
  | MaxMetaspaceSize      | 限制Metaspace增长上限，防止因为某些情况导致Metaspace无限使用本地内存，影响到其他程序，默认为4096M |
  | MinMetaspaceFreeRatio | 当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数，那么虚拟机增长Metaspace的大小，默认为40，即40% |
  | MaxMetaspaceFreeRatio | 当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放部分Metaspace空间，默认为70，即70% |
  | MaxMetaspaceExpanison | Metaspace增长时的最大幅度，默认值为5M                        |
  | MinMetaspaceExpanison | Metaspace增长时的最小幅度，默认为330KB                       |

###  什么是CompressedClassSpace?

- 开启了指针压缩之后,类信息放在这里
- 

[Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法） - duanxz - 博客园 (cnblogs.com)](https://www.cnblogs.com/duanxz/p/3520829.html) 

## synchronized

 [java并发笔记四之synchronized 锁的膨胀过程（锁的升级过程）深入剖析 - 王六六666 - 博客园 (cnblogs.com)](https://www.cnblogs.com/yuhangwang/p/11295940.html) 

为什么计算了hashcode之后就无法使用偏向锁?

- 对象默认的hashcode是根据os::random 生成的随机码,记录在markword中
- 而在偏向锁使用时,会将这部分空间替代为获取锁的线程id,hashcode永久丢失
- 轻量级锁会将markword中的这部分数据复制到lock record中
- 重量级锁会将markword中这部分复制到monitor对象中